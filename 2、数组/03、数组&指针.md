# 数组&指针

### 数组&指针
数组的指针其实就是数组在内存中的起始地址，也即一个数组中首元素在内存中的地址。
>* 数组名a 
>>* 地址常量【不可改变】，故程序中不能对其赋值。（不可以作a++、a--运算）
>* 指针变量p
>>* 任何时刻只能指向其中的一个元素。
>>* 可以进行p++、p--等操作，分别指向下一个或上一个数组元素
```
type a[n],*p;                // 数组名a是地址
p = a;                       // p = &a[0],把数组a首元素的地址赋值给指针变量p

a + m == &a[m];              // 相同的地址
*(a + m) == a[m];            // 相同的值
```
<table>
    <tr>
        <td rowspan=4>地址</td>
        <td rowspan=2>地址法</td>
        <td>a、a+1、……、a+n</td>
    </tr>
    <tr>
        <td>p、p+1、……、p+n</td>
    </tr>
    <tr>
        <td rowspan=2>下标法</td>
        <td>&a[0]、&a[1]、……、&a[n]</td>
    </tr>
     <tr>
        <td>&p[0]、&p[1]、……、&p[n]</td>
    </tr>  
     <tr>
        <td rowspan=4>值</td>
        <td rowspan=2>指针法</td>
        <td>*a、*（a+1）、……、*（a+n）</td>
    </tr>
    <tr>
        <td>*p、*（p+1）、……、*（p+n）</td>
    </tr>
    <tr>
        <td rowspan=2>下标法</td>
        <td>a[0]、a[1]、……、a[n]</td>
    </tr>
     <tr>
        <td>p[0]、p[1]、……、p[n]</td>
    </tr>     
    
</table>

> **计算机内部硬件层面最终都是使用指针（地址），编译器会把数组表示法转换成指针表示法，再去访问地址。**

> 在C语言中，指针加1指的是增加一个存储单元。对数组而言，加1后的地址是下一个元素的地址，而不是下一个字节的地址【所以必须声明指针所指向对象类型】

<br>

### 数组指针
```
// 指针直接指向二维数组
type aa[n][m];                      // 定义二维数组
type (*pp)[m] = aa;                 // 定义数组指针【二维数组容量不可忽略】

// 地址
*pp == aa[0];                       // 单次解引用，指针指向内层数组。

// 值
**pp == aa[0][0];                   // 双重解引用，指针直接指向内层数组元素。
*pp[0] == aa[0][0];
aa[i][j] == *(*(aa+i)+j);           // 建议使用数组表示法，而不是指针表示法
```
```
// 将二维数组转化为一维数组，再使用指针
type aa[n][m];                      // 定义二维数组
type (*p)[nm] = &aa;                // 定义数组指针，直接指向一维数组

// 地址
(*p) == a[0];

// 值
(*p)[0] == *(*P) == aa[0][0];        
(*p)[x] == *((*P+x//n)+x%n) == aa[x//n][x%n]; 
```


